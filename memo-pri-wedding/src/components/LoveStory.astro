---
// Props que se podrían pasar para personalizar
---

<section id="love-story" class="section bg-white overflow-hidden py-8 md:py-12 px-0 relative">
  <img src="/images/flores_nuestra_historia.png" alt="Flower decoration" class="absolute top-0 left-0 w-20 md:w-40 h-auto z-20" />
  
  <div class="container mx-auto px-4">
    <h2 class="section-title text-[#004AAD] font-lichtner">Nuestra Historia</h2>

    <div class="max-w-3xl mx-auto text-center mb-16 px-8">
      <p class="text-lg text-[#004AAD] leading-relaxed font-script">
        Somos Pri y Memo.
        Nos conocimos como no podía ser de otra forma: en una carrera de obstáculos.
        Ella decía que su abuelo fue presidente de Patronato.
        Él prometía que podía ahorrarle en la factura de luz… y que si lo lograba, le debía una birra.
        Spoiler: hubo ahorro, y todavía le debe la birra.
        <br><br>
        Desde entonces, compartimos caminos, risas, viajes, naturaleza… y muchos sueños.
        <br><br>
        Un día, tomando mate en una playa de Fuerteventura, el último mate le tocó a Pri.
        Y como dice la tradición en Argentina: el que toma el último mate, se casa.
        Así, entre arena y viento, llegó la propuesta. Simple y auténtica, como nosotros.
        <br><br>
        Hoy queremos celebrar el amor con las personas que más queremos.
        Nos llena de alegría saber que vienen desde distintos rincones de Argentina, de Barcelona (nuestra casa hoy), y de muchos otros lugares.
        Gracias por estar. Por venir. Por compartir este momento con nosotros.
      </p>
    </div>
  </div>
  
  <!-- Mirrored image moved here -->
  
  <div class="photo-carousel-container w-full relative">
    <!-- Navigation Buttons Container - Moved Above Viewport -->
    <div class="flex justify-end space-x-2 mb-2 px-4">
      <button class="nav-button prev p-1 focus:outline-none transition-opacity disabled:opacity-40 disabled:cursor-not-allowed">
        <svg class="w-6 h-6 text-[#004AAD] hover:opacity-75 transition-opacity" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24">
          <line x1="19" y1="12" x2="5" y2="12"></line>
          <polyline points="12 19 5 12 12 5"></polyline>
        </svg>
      </button>
      <button class="nav-button next p-1 focus:outline-none transition-opacity disabled:opacity-40 disabled:cursor-not-allowed">
        <svg class="w-6 h-6 text-[#004AAD] hover:opacity-75 transition-opacity" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" viewBox="0 0 24 24">
          <line x1="5" y1="12" x2="19" y2="12"></line>
          <polyline points="12 5 19 12 12 19"></polyline>
        </svg>
      </button>
    </div>

    <div id="carousel-viewport" class="relative w-full overflow-hidden">
      <div id="carousel-items" class="flex h-full">
        <!-- Slides will be injected here by JavaScript -->
      </div>
    </div>
  </div>
      
</section>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const carouselContainer = document.getElementById('carousel-items');
    const carouselViewport = document.getElementById('carousel-viewport');
    const prevBtn = document.querySelector('.nav-button.prev');
    const nextBtn = document.querySelector('.nav-button.next');
    
    if (!carouselContainer || !carouselViewport || !prevBtn || !nextBtn) {
        console.error("Carousel elements not found!");
        return;
    }

    const mobileBreakpoint = 768;
    const slidesToDisplayDesktop = 5;
    const slidesToDisplayMobilePartial = 1.2; // Show 1 full and part of the next

    let slideWidthPercentage = 100 / slidesToDisplayDesktop; // Default desktop
    let slides = [];
    let totalSlides = 0;
    let currentIndex = 0;
    let maxIndex = 0; 
    let slideWidthPx = 0; 
    let viewportWidth = 0; // Store viewport width
    let maxNegativeTranslate = 0; // Max scroll position

    // --- Touch related variables ---
    let isDragging = false;
    let startX = 0;
    let currentTranslate = 0;
    let prevTranslate = 0;
    const swipeThreshold = 30; // Reduced threshold for swipe detection

    function setupCarouselHeightAndSlides() {
        viewportWidth = carouselViewport.offsetWidth; // Store viewport width
        if (viewportWidth === 0) return;

        const isMobile = window.innerWidth < mobileBreakpoint;
        
        slideWidthPercentage = isMobile 
            ? (100 / slidesToDisplayMobilePartial) 
            : (100 / slidesToDisplayDesktop);
        
        slideWidthPx = viewportWidth * (slideWidthPercentage / 100);
        
        carouselViewport.style.height = `${slideWidthPx}px`; // Maintain square aspect ratio based on new width
        carouselViewport.style.overscrollBehavior = 'contain'; // Prevent bounce effect

        carouselContainer.innerHTML = ''; // Clear existing placeholders if any

        // --- Load actual images ---
        const imageBaseUrl = '/images/love-story/';
        const imageNames = Array.from({ length: 10 }, (_, i) => `love_story_${i + 1}.jpeg`);

        imageNames.forEach(imageName => {
            const slide = document.createElement('div');
            slide.classList.add(
                'photo-carousel-slide',
                'flex-shrink-0',
                'h-full',
                'box-border',
                'overflow-hidden', // Ensure image stays within bounds
                'select-none' // Prevent text selection during drag
            );
            // Apply width using px for precision needed with partial visibility
            slide.style.width = `${slideWidthPx}px`; 

            const img = document.createElement('img');
            img.src = `${imageBaseUrl}${imageName}`;
            img.alt = 'Photo from our story';
            img.classList.add(
                'w-full', 'h-full', 'object-cover', 'aspect-square',
                'filter', 'grayscale'
            );
            img.loading = 'lazy';
            img.ondragstart = () => false; 

            slide.appendChild(img);
            carouselContainer.appendChild(slide);
        });
        // --- End image loading ---

        slides = carouselContainer.querySelectorAll('.photo-carousel-slide');
        totalSlides = slides.length;
        
        // Max index allows scrolling until the start of the last slide is aligned with the start of the viewport
        maxIndex = totalSlides > 0 ? totalSlides - 1 : 0;
        
        // Calculate max scroll position: allows scrolling until end of last slide aligns with end of viewport
        const totalCarouselWidth = totalSlides * slideWidthPx;
        maxNegativeTranslate = totalCarouselWidth > viewportWidth ? -(totalCarouselWidth - viewportWidth) : 0;

        // Ensure currentIndex is valid after setup/resize
        currentIndex = Math.max(0, Math.min(currentIndex, maxIndex)); 
        
        // Adjust currentTranslate based on potential resize, clamp within new bounds
        currentTranslate = Math.max(maxNegativeTranslate, Math.min(0, currentTranslate));
        prevTranslate = currentTranslate; // Sync prevTranslate
        applyTransform(false); // Apply initial/resized transform without animation
        updateButtonStates(); // Update buttons based on current position

        carouselViewport.style.cursor = 'grab';
    }

    // Renamed from updateCarouselState to clarify purpose (button clicks/programmatic changes)
    function animateToSlide(targetIndex) {
        if (totalSlides === 0) return;

        currentIndex = Math.max(0, Math.min(targetIndex, maxIndex)); // Clamp target index
        currentTranslate = Math.max(maxNegativeTranslate, Math.min(0, -currentIndex * slideWidthPx));
        prevTranslate = currentTranslate; // Update prevTranslate for consistency
        
        applyTransform(true); // Apply transform WITH animation
        updateButtonStates(); // Update buttons
    }

    // New function to apply transform and manage transition
    function applyTransform(animate = true) {
      carouselContainer.style.transition = animate 
          ? 'transform 0.3s ease-out' 
          : 'none'; 
      carouselContainer.style.transform = `translateX(${currentTranslate}px)`;
      
      // Ensure transition is re-enabled for subsequent interactions if it was disabled
      // Use requestAnimationFrame for smoother transition re-enabling after 'none'
      if (!animate) {
          requestAnimationFrame(() => {
              requestAnimationFrame(() => { // Double rAF for better cross-browser compatibility
                  carouselContainer.style.transition = 'transform 0.3s ease-out';
              });
          });
      }
    }

    // New function to specifically update button states based on currentTranslate
    function updateButtonStates() {
        if (totalSlides === 0) {
            prevBtn.disabled = true;
            nextBtn.disabled = true;
            return;
        }
        // Disable prev if we are at or very close to the beginning (allowing for float inaccuracies)
        prevBtn.disabled = currentTranslate >= -0.1;
        // Disable next if we are at or very close to the maximum scroll position
        nextBtn.disabled = currentTranslate <= maxNegativeTranslate + 0.1;
    }
    
    setupCarouselHeightAndSlides(); // Initial setup
    
    // --- Button Event Listeners ---
    prevBtn.addEventListener('click', () => {
      // Calculate target index based on current position for smoother button navigation
      const currentClosestIndex = Math.round(-currentTranslate / slideWidthPx);
      animateToSlide(currentClosestIndex - 1); // Animate to the previous slide
    });
    
    nextBtn.addEventListener('click', () => {
      const currentClosestIndex = Math.round(-currentTranslate / slideWidthPx);
      animateToSlide(currentClosestIndex + 1); // Animate to the next slide
    });

    // --- Touch Event Listeners ---
    carouselViewport.addEventListener('touchstart', (e) => {
        if (totalSlides === 0) return;
        isDragging = true;
        startX = e.touches[0].clientX;
        const transformMatrix = window.getComputedStyle(carouselContainer).getPropertyValue('transform');
        if (transformMatrix !== 'none') {
            prevTranslate = parseFloat(transformMatrix.split(',')[4] || 0);
        } else {
            // Fallback if transform is 'none' (shouldn't usually happen during interaction)
            prevTranslate = currentTranslate; 
        }
        carouselContainer.style.transition = 'none';
        carouselViewport.style.cursor = 'grabbing';
    }, { passive: true }); 

    carouselViewport.addEventListener('touchmove', (e) => {
        if (!isDragging || totalSlides === 0) return;
        const currentX = e.touches[0].clientX;
        const deltaX = currentX - startX;
        currentTranslate = prevTranslate + deltaX;

        // Clamp translation within bounds [maxNegativeTranslate, 0]
        currentTranslate = Math.max(maxNegativeTranslate, Math.min(0, currentTranslate));

        // Apply immediate transform for visual feedback WITHOUT animation
        applyTransform(false);
        updateButtonStates(); // Update buttons immediately during drag
    });

    carouselViewport.addEventListener('touchend', () => {
        if (!isDragging || totalSlides === 0) return;
        isDragging = false;
        carouselViewport.style.cursor = 'grab';

        // Store the final position achieved by dragging
        prevTranslate = currentTranslate;
        
        // NO automatic snapping/animation here. Position is kept.
        // Buttons are already updated during touchmove.
    });

    carouselViewport.addEventListener('touchcancel', () => {
        if (!isDragging || totalSlides === 0) return;
        isDragging = false;
        carouselViewport.style.cursor = 'grab';
        // Optional: Snap back to prevTranslate if needed, but current behavior is likely fine
        // currentTranslate = prevTranslate;
        // applyTransform(false);
        updateButtonStates(); 
    });

    // --- Resize Listener ---
    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
            setupCarouselHeightAndSlides(); 
        }, 250);
    });

  });
</script>